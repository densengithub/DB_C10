// Updated date : 2019/08/12
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// WRITE        ADDRESS(32bits) DATA(32bits)  ByteEnable(4bits) :write data to address                          //
// READ         ADDRESS(32bits) DATA(32bits)  BitEnable(32bits) :read address,and then compare with data        //
// WAIT         ADDRESS(32bits) DATA(32bits)  BitEnable(32bits) :read address until equal to data               //
// INITFILE     FILENAME                                        :write file to address(@address in the file)    //
// INITBFILE    ADDRESS(32bits) FILENAME(bin)                   :write file to address                          //
// DUMP         ADDRESS(32bits) FILENAME      SIZE(byte)        :read address,then write to file                //
// DUMPB        ADDRESS(32bits) FILENAME(bin) SIZE(byte)        :read address,then write to file                //
// WAIT         TIME(us)                                        :host model sleep                               //
// END                                                          :stop simulation                                // 
// SET_SPIWRCLK Frequency(Mhz)                                  :set spi frequency for write command            // 
// SET_SPIRDCLK Frequency(Mhz)                                  :set spi frequency for read command             // 
// change note:
// 07/27/2018: 
//            modify 0xd8100020 register to set auto_io_deep_pdn=1,auto_io_ctrl_pdn=1, IO18V=0
//            add 0xd810002c register to set auto_srf_en=1, auto_srf_timer=64x4 mphyclk, auto_pdn_en=1, auto_pdn_timer=64x4 mphyclk
//            modify 0xD8000018 register to set NCLK to 792/3=264MHz
//05/02/2019: If needing to use ZQCL or ZQCS command, must turn off auto_srf_en parameter(0xd810002c[28]) and auto_pdn_en(0xd810002c[12])
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

if (read_mask(0xd8000000, 0x00000003)!=0x0003) {    // Booting mode
    WRITE(0xD800000C, 0x002a8802);  // Do not reset AXI/ARM
    WRITE(0xD8000018, 0x002a8804);  // Do not reset AHB, SD/SD1/SD0
    WRITE(0xD800001C, 0x7fff8804);  // Do not reset APB
    WRITE(0xD8000050, 0x6c000c02);  // Do not reset RISC bus to store the booting info on register
    WRITE(0xD800006C, 0x000a880a);  // Do not reset NOR
} else {
    WRITE(0xD800000C, 0xc02a8802);  // AX2CLK    PLL1_OUT1 / 1 (AX2CLK      792MHz, ACLK 396MHz)
    WRITE(0xD8000018, 0xf02a8804);  // NCLK      PLL1_OUT1 / 4 (AHB/RISC    198MHz)
    WRITE(0xD800001C, 0x00008804);  // WCLK      PLL1_OUT1 / 4 (APB         198MHz)
    WRITE(0xD8000050, 0x00000c02);  // Reset and Enable RISC clock
    WRITE(0xD800006C, 0x800a880a);  // SCLK      PLL1_OUT1 / 1 (SPI        79.2MHz)
}  

// Reset and enable clock     
WRITE(0xD8000008,0x80028808);  // BCLK      PLL1_OUT1 / 8 (BIST        99MHz)  
WRITE(0xD8000010,0x80028200);  // MPHYCLK_ECO   PLL1_OUT1 / 2 (Memory PHY  396MHz) 
WRITE(0xD8000014,0x802a9803);  // MCLK      PLL1_OUT2 / 3 (Memory wrap 324MHz)             
WRITE(0xD8000020,0x00aaaaaa);  // APB Reset, Enable APB Clock                  
WRITE(0xD8000024,0xc2af9802);  // GCLK      PLL1_OUT2 / 2 (2D         486MHz)             
WRITE(0xD8000028,0xe02ac801);  // DCLK      PLL3_OUT1 / 1 (LCD        166MHz)
WRITE(0xD800002C,0xc02a8803);  // DPCLK     PLL1_OUT1 / 3 (DPCLK      264MHz)  
WRITE(0xD8000030,0xfcaa9803);  // ICLK      PLL1_OUT2 / 3 (VP         324MHz)          
WRITE(0xD8000034,0xcaaa9802);  // XCLK      PLL1_OUT2 / 2 (Video      486MHz)          
WRITE(0xD8000038,0xc02a9804);  // JCLK      PLL1_OUT2 / 4 (JPEG       243MHz)           
WRITE(0xD800003c,0xf0aac804);  // ZCLK      PLL3_OUT1 / 4 (I2S     12.288MHz)
WRITE(0xD8000040,0x0002c802);  // AMCLK     PLL3_OUT1 / 2 (AMCLK   12.288MHz)
WRITE(0xD8000044,0xc00a8804);  // KCLK      PLL1_OUT1 / 4 (MIPI       198MHz)  
WRITE(0xD8000048,0xc0028814);  // KESCCLK   PLL1_OUT1 / 20(MIPI        20MHz)  
WRITE(0xD800004C,0xc0029804);  // KDSICLK   PLL1_OUT2 / 4 (MIPI       243MHz)                    
WRITE(0xD8000054,0x8000000a);  // Reset and Enablle TSI clock        
WRITE(0xD8000058,0x80029804);  // PCLK      PLL1_OUT2 / 4 (PCR        243MHz)            
WRITE(0xD800005C,0x802a9804);  // WSCLK     PLL1_OUT2 / 4 (WSCLK      243MHz)        
WRITE(0xD8000060,0xc00ad802);  // CAPCLK    PLL3_OUT2 / 2 (CAP         83MHz)             
WRITE(0xD8000064,0x8000000a);  // Reset and Enable USB clock                   
WRITE(0xD8000068,0xc02ac801);  // REFCLK    PLL3_OUT1 / 1 (MAC         50MHz)     
WRITE(0xD8000070,0x8000000a);  // Reset and Enable UIEnc clock   

// Un-Reset                                                                
WRITE(0xD8000008,0x00000808); // BCLK      PLL1_OUT1 / 8 (BIST        99MHz)                                                             
WRITE(0xD800000C,0x002a8802); // AX2CLK    PLL1_OUT1 / 1 (AX2CLK      792MHz, ACLK 396MHz)                 
WRITE(0xD8000010,0x80028200); // MPHYCLK_ECO   PLL1_OUT1 / 2 (Memory PHY  396MHz) 
WRITE(0xD8000014,0x002a9803); // MCLK      PLL1_OUT2 / 3 (Memory wrap 324MHz)   
WRITE(0xD8000018,0x002a8804); // NCLK      PLL1_OUT1 / 4 (AHB/RISC    198MHz)       
WRITE(0xD800001c,0x00008804); // WCLK      PLL1_OUT1 / 4 (APB         198MHz)                
WRITE(0xD8000020,0x00aaaaaa); // APB Reset, Enable APB Clock                  
WRITE(0xD8000024,0x00001802); // GCLK      PLL1_OUT2 / 2 (2D         486MHz)             
WRITE(0xD8000028,0x00004801); // DCLK      PLL3_OUT1 / 1 (LCD        166MHz)
WRITE(0xD800002C,0x002a8803); // DPCLK     PLL1_OUT1 / 3 (DPCLK      264MHz)  
WRITE(0xD8000030,0x00001803); // ICLK      PLL1_OUT2 / 3 (VP         324MHz)          
WRITE(0xD8000034,0x00001802); // XCLK      PLL1_OUT2 / 2 (Video      486MHz)
WRITE(0xD8000038,0x00201804); // JCLK      PLL1_OUT2 / 4 (JPEG       243MHz)           
WRITE(0xD800003c,0x00002804); // ZCLK      PLL2_OUT1 / 4 (I2S     12.288MHz)
WRITE(0xD8000040,0x00004802); // AMCLK     PLL3_OUT1 / 2 (AMCLK   12.288MHz)
WRITE(0xD8000044,0x00000804); // KCLK      PLL1_OUT1 / 4 (MIPI       198MHz)  
WRITE(0xD8000048,0x00000814); // KESCCLK   PLL1_OUT1 / 20(MIPI        20MHz)                                        
WRITE(0xD800004C,0x00001804); // KDSICLK   PLL1_OUT2 / 4 (MIPI       243MHz)                                              
WRITE(0xD8000050,0x00000c02); // Reset and Enable RISC clock      
WRITE(0xD8000054,0x00000000); // Reset and Enablle TSI clock        
WRITE(0xD8000058,0x00001004); // PCLK      PLL1_OUT2 / 4 (PCR        243MHz)            
WRITE(0xD800005C,0x00001804); // WSCLK     PLL1_OUT2 / 4 (WSCLK      243MHz)        
WRITE(0xD8000060,0x00086000); // CAPCLK    PLL3_OUT3 / 2 (CAP         27MHz from PLL3 output3)            
WRITE(0xD8000064,0x0000000a); // Reset and Enable USB clock                   
WRITE(0xD8000068,0x00004001); // REFCLK    PLL3_OUT1 / 1 (MAC         50MHz)
WRITE(0xD800006C,0x000a8806); // SCLK      PLL1_OUT1 / 6 (SPI        132MHz)            
WRITE(0xD8000070,0x00000000); // Reset and Enable UIEnc clock

//HX add (depop method)
WRITE(0xD800003c,0x02002804); // ZCLK      PLL2_OUT1 / 4 (I2S     12.288MHz)
WRITE(0xD01000D0,0x0000000F); // DAC depop (for DAC faraday)

// Set Host clock to PLL2 temporary, and set it to PLL1_OUT2 latter
//##################################################################################################

//##################################################################################################

/////////////////////////////////////////////////////////
//                                                     //
//         PLL Setting                                 //
//                                                     //
/////////////////////////////////////////////////////////
//#####################################################//
//# PLL1_N1   = 12MHz     * 1/1  * 66  * 1/1 = 792MHz, //
//# PLL1_N2   = 12MHz     * 1/1  * 81  * 1/1 = 972MHz, //
//#####################################################//  
WRITE(0xD8000108,0x20510101);
WRITE(0xD800010c,0x80000000); 
WRITE(0xD800010c,0xF3000000); 
WAIT(220); 
WRITE(0xD800010c,0x80000000); 

WRITE(0xD8000100,0x20420101); 
WRITE(0xD8000104,0x80000000); 
WRITE(0xD8000104,0xF3000000); 
WAIT(220); // wait pll stable
WRITE(0xD8000104, 0x80000000); 
//#####################################################//                                     
// PLL2_N1   = 12MHz * 1/1 * 56  * 1/2 = 336MHz
// PLL2_N2   = 12MHz * 1/1 * 56  * 1/2 = 336MHz
//#####################################################// 
WRITE(0xd8000118,0x20380201); 
WRITE(0xd800011c,0x80000000); 
WRITE(0xd800011c,0xF3000000); 
WAIT(220);    
WRITE(0xd800011c,0x80000000);             
WRITE(0xd8000110,0x20380201); 
WRITE(0xd8000114,0x80000000); 
WRITE(0xd8000114,0xF3000000); 
WAIT(220); // wait pll stable
WRITE(0xd8000114,0x80000000);        
            
//#####################################################//             
// PLL3_N1   = 12MHz     * 1/1  * 50  * 1/12 = 50MHz
// PLL3_N2   = 12MHz     * 1/1  * 72  * 1/32 = 27MHz
// PLL3_N3   = 12MHz     * 1/1  * 83  * 1/6  = 166MHz
//#####################################################//
WRITE(0xD8000120,0x20320c01); 
WRITE(0xD8000124,0x80000000); 
WRITE(0xD8000124,0xF3000000); 
WAIT(220); 
WRITE(0xD8000124,0x80000000);

WRITE(0xD8000128,0x20482001); 
WRITE(0xD800012c,0x80000000); 
WRITE(0xD800012c,0xF3000000); 
WAIT(220); 
WRITE(0xD800012c,0x80000000);

//WRITE(0xD8000130,0x20530601); 
//WRITE(0xD8000134,0x80000000); 
//WRITE(0xD8000134,0xF3000000); 
//WAIT(220); 
//WRITE(0xD8000134,0x80000000);

//#####################################################//
// ADPLL2_N1 = 161.28MHz * 1/50 * 196 * 1/56 = 11.2896MHz
// ADPLL2_N2 = 126MHz    * 1/25 * 128 * 1/4  = 161.28MHz
// ADPLL2_N3 = 48MHz     * 1/4  * 42  * 1/4  = 126MHz
//#####################################################//
//WRITE(0xD8000150,0x402a0404);
//WRITE(0xD8000154,0x090f0000);

//WRITE(0xD8000140,0x50800419);
//WRITE(0xD8000144,0x090f0000);
//WRITE(0xD8000130,0xd0c43832);
//WRITE(0xD8000134,0x090f0000);

///////////////////////////////////////////////////                                          
// faraday memory controller initialized process //                                            
///////////////////////////////////////////////////                                       

WRITE(0xd8100350,0x00c50474);  // set ddrphy parameter: w0vrefddren=1,w0vrefddrsel=4,IO15V=1,SIO=0,SELFBIAS=1,VREF_SELECT=4,DLLFRANGE=7,DDR3=1,LPDDR2=0,MDDR1=0       
WRITE(0xd8100354,0x00000003);  // set ddrphy parameter: DSRONB,CLOCK_EN                        
WRITE(0xd8100358,0x00008008);  // set ddrphy parameter: CONUPDATE,DUTYSEL                       


WAIT(1);                       // wait 1 us 
WRITE(0xd8100340,0x00000001);  // release PLLPDN

WAIT(50);                      // wait 50 us
WRITE(0xd8100340,0x00000003);  // release PLLRESETN

WAIT(1);                       // wait 1 us
WRITE(0xd8100340,0x00000007);  // release DLLPDN

WAIT(20);
WRITE(0xD8000010,0x00028200); // MPHYCLK_ECO   PLL1_OUT1 / 2 (Memory PHY  396MHz)


WAIT(10);
WRITE(0xd8100028,0x00001041); // set DDR2/DDR3 PHY pin PMOS/NMOS driving strength register

WAIT(100);

///////////////////////////////////////////////////
// set memory controller register MRS, AC timing //
// MPHYCLK = 396Mhz, 1Cycle=2.52 ns, RZQ=240ohm  //
///////////////////////////////////////////////////
WRITE(0xd8100000,0x08005d03); // set BYONE[18]=0,DDR_MODE[19:16]=0(0:DDR3 1:2 mode,3:DDR2 1:2 mode,7:DDR2 1:1 mode),POST_REF[15:13]=2,auto_refresh_cmd[12:10]=7,DRAM_width[9:8]=1(16-bit),GDS[2:0]=3
WRITE(0xd810000c,0x00000058); // set MR2 MR3(A[2:0]=0(PASR=0),A[5:3]=3(CWL=8),A[6]=1(ASR=1,IF ASR=1,tref must divide by 2),A[7]=0(SRT=0),A[10:9]=0(Rtt_WR=0,0:Dynamic ODT off,1:RZQ/4,2:RZQ/2,3:Reserved))
WRITE(0xd8100008,0x00001c70); // set MR0(BL=8,CL=11(WL=CL-1),WR=12,PPD[A12]:0(slow exit from precharge power-down mode)) 
                              //     MR1(DLL:0(enable),output driver impedance:ZRQ/6=40,Rtt_Nom(A[9]A[6]A[2])=0(0:disable,1:RZQ/4,2:RZQ/2,3:RZQ/6,4:RZQ/8,(6,7):Reserved),AL=0(disable),write leveling enable:0(disable),output buffer enable:0(enable)) 
WRITE(0xd8100010,0x00000043); // set rank0/rank1 type base address 128M Bytes, Row_bit 13, Col_bit 10, bank_bit 3

WRITE(0xd8100014,0x2c0e130d); // set timing parameter 0(TRFC[31:24]=45(113.3ns>110ns), TFAW[20:16]=15(37.8ns>35ns), TRC[13:8]=20(50.4ns>48ns), TRAS[4:0]=14(35.2>34ns))
WRITE(0xd8100018,0x53b62525); // set timing parameter 1(TWTR[30:28]=5(10ns>max(4dramclk=5ns,7.5ns)),TRTP[26:24]=4(10ns>max(4dramclk=5ns,7.5ns)),TWR[23:20]=b(17.6ns>15ns),TMOD[19:16]=7(17.6ns>max(12dramclk=15ns, 15ns)),
                              // TMRD[15:12]=3mclk(6tck)>4tck,TRP[11:8]=6(15.1ns>14ns),TRRD[7:4]=3(7.5ns>max(4dramclk=5ns, 6ns)),TRCD[3:0]=6(15.2ns>14ns))
WRITE(0xd810001c,0x0100215f); // set timing parameter 2(additional delay, TXSR[15:8]=(33x8x2.52)=665.2ns>640ns, TREFI[7:0]=(95x32x2.52=7660ns < spec 3900nsx2(ESMT))) 

WRITE(0xd8100020,0x00008f81); // set DDR2/DDR3 PHY command and data block register,auto_io_deep_pdn[15]=1, auto_io_ctrl_pdn[7]=1,io18v[6]=0,ODT[2:0]=1(0->disable,1->120ohm,2->60ohm,(3,4)->40ohm,5->30ohm,6->24ohm,7->20ohm)
//WRITE(0xd8100024,0x11111111); // set DDR2/DDR3 PHY read data delay
//WRITE(0xd8100028,0x000007a3); // set DDR2/DDR3 PHY comp block register
WRITE(0xd810002c,0x00401040); // set auto_srf_en=1, auto_srf_timer=64x4 mphyclk, auto_pdn_en=1, auto_pdn_timer=64x4 mphyclk
WRITE(0xd8100030,0x90000F00); // set global channel arbiter parameter,RW_Grp_EN[31]=1,Indep_RW_EN[30]=0,group_grant_count_low[28:24]=16,BstOriArb[15:8]=0x04,Ch_hi_prior[7:0]=0x0E
WRITE(0xd8100034,0x07050502); // set grant count of channel 0 to channel 3
WRITE(0xd8100038,0x05050505); // set grant count of channel 7 to channel 4
WRITE(0xd810003c,0x00040013); // set relationship between wrdata and dqsoe, rddata and rdcmd tphy_wrlat = (Wl/2)-1
WRITE(0xd8100074,0x22222222); // set dqs filtering window
WRITE(0xd8100078,0x00000088); // set DLSEL_WR_BYTE0=8,DLSEL_WR_BYTE1=8
WRITE(0xd8100134,0x00307722); // set driving impedance DDRIO, RONMD_DATA[6:4]=2(80ohm),RONMD_CMDADDR[2:0]=2(80ohm)[0->240ohm,1->120ohm,2->80ohm,3,4->60ohm,5->48ohm,6->40ohm,7->34ohm]
WRITE(0xd81002c0,0x88011010); // fix 2D VP access same memory to cause engine busy issue(ECO).
///////////////////////////////////////////////////

// change USB priority from 6 to 0 //
WRITE(0xd8100288,0x12345607);

// fire memory controller to initiate memory //
WAIT(100);                     // wait 100 us
WRITE(0xd8100340,0x0000000f);  // release RESETN
WRITE(0xd8100138,0x00000105);  // reset elastic fifo(EFIFO) 
WRITE(0xd8100004,0x00000001);  // fire memory initiated sequence

// Save desired target AX2CLK after maskrom booting. (Reference: 0xD800000C)
WRITE(0xD800027C, 0x002a8801);  // AX2CLK    PLL1_OUT1 / 1 (AX2CLK 792MHz)

// GPIO settings
WRITE(0xD1000044, 0x00000030);
WRITE(0xD1000058, 0xaaaaa8aa);